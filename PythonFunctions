# step 1: exploratory data analysis--organizing, ploting, computing a few numerical summaries and draw conclusion from data (John Tukey)
# importing data 
import pandas as pd
df_swing = pd.read_csv('2018_swing_states.csv')
df_swing[['state', 'county', 'dem_share']]

## 1.1 graphical data analysis

## use the default settings of Seaborn: a matplotlib based statistical data visualization package
import matplotlib.pyplot as plt
import seaborn as sns
sns.set()

# hostogram: the height of each bar is the number of (y) that had the give level (x)

_ =  plt.hist(df_swing['dem_share']) # pass a column in a dataframe, or a NumPy array
_ = plt.xlabel('percent of vaote for Obama') # always label axes
_ = plt.ylabel('number of counties')
plt.show()

# histogram have binning bias: the same data maybe interpreted differently depending on choice of bins
# not all data is plotted, data are sweeped into bins and loosing their actual values
bin_edges = [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100]
_ =  plt.hist(df_swing['dem_share'], bins = bin_edges) # specifiy bin edges

# A commonly used rule of thumb for choosing number of bins: the "Square root rule"
import numpy as np
#compute number of data points
n_data = len(df_swing['dem_share'])
n_bins = int(np.sqrt(n_data))
_ =  plt.hist(df_swing['dem_share'], bins = n_bins) # or specify the number of bins 

# plot all of your data: bee swarm plots
_ = sns.swarmplot(x='state', y='dem_share', data = df_swing)
_ = plt.xlabel('state')
_ = plt.ylabel('percent of vote for Obama')
plt.show()

# bee swarm plots have a limit to their efficacy

########## Empirical cumulative distribution function (ECDF) #####################
In a workflow, it's almost always plot the ECDF first, it shows all the data and give a complete picture of how the data are distributed
# a X-value of ECDF is the quantity you are measuring
# the y_value is the fraction of data points that have a value smaller than the corresponding x-value

imporot numpy as np
### the ecdf function takes a 1D array of data as input and returns the x and y values of the ECDF
def ecdf(data):
    n = len(data)
    x = np.sort(data)
    y = np.arange(1, n+1) /n
    return x, y
    
x , y = ecdf(df_swing['dem_share'])
_ = plt.plot(x, y, marker = '.', linestyle = 'none')
_ = plt.xlabel('percent of vote for Obama')
_ =  plt.ylabel('ECDF')
plt.margins(0.02) # keep data off plot edges
plt.show()

# compare 2 or more distributions using ECDFs
x_set, y_set = ecdf(setosa_petal_length)
x_vers, y_vers = ecdf(versicolor_petal_length)
x_virg, y_virg = ecdf(virginica_petal_length)

# Plot all ECDFs on the same plot
_ = plt.plot(x_set, y_set, marker ='.', linestyle = 'none')
_ = plt.plot(x_vers, y_vers, marker ='.', linestyle = 'none')
_ = plt.plot(x_virg, y_virg, marker ='.', linestyle = 'none')

# Annotate the plot
plt.legend(('setosa', 'versicolor', 'virginica'), loc='lower right')
_ = plt.xlabel('petal length (cm)')
_ = plt.ylabel('ECDF')

# Display the plot
plt.show()

#goal: computing parameters and their confidence intervals, and do hypothesis tests
